# Deprecation
> 모든 시스템은 나이를 먹는다. 나이가 많아져 낡아진 시스템은 계속 끌고 가는 것보다 완전히 떼어내는 편이 나을 때가 많다. 이 때 이 시스템을 순차적으로 완전히 걷어내는 과정을 폐기라 한다.

폐기는 시스템 관리에 세월적인 측면까지 고려해야하는 엄밀하게 말해서는 프로그래밍이 아닌 소프트웨어 엔지니어링 원칙에 속하는 또 다른 주제이다. 
장기간 운영되는 소프트웨어 생태계에서는 폐기 계획을 제대로 세우고 올바르게 실행해야지만 새로운 시스템을 들이는 과정에서 중복 투자와 복잡성을 줄여줄 수 있다. 
## Why deprecate?
> "코드는 자산이 아니라 부채다."

 코드에는 구축 비용, 유지보수 비용 등 여러 비용이 따라오게된다.  비용이 계속 되어 투자되는 시스템에는 이를 계속 운영할지 아니면 슬슬 폐기를 해야할지 선택해야하는 순간이 반드시 찾아오게 된다. 
 하지만, 시스템이 오래되었다고 무조건 폐기시키는것은 아니다. 여러 해에 걸쳐 정교하게 다듬어져 완벽한 시스템은 폐기할 필요가 없다. 시스템에서 폐기시켜야 하는것은, **시대에 뒤쳐졌음을 보여줄 수 있고 비슷한 기능의 대체재**가 존재하는 시스템이다.


## Why Is Deprecation So Hard?
> 하이럼의 법칙 : -   API를 사용하는 유저가 충분히 많아지면 내가 만든 의도와 상관없이 사용자들의 의도대로 API가 작동된다.
- 시스템은 사용자가 많아질수록 새로운 방식으로 이용될 가능성이 커져서 폐기 작업을 어렵게 만든다.
- 일반적으로 폐기를 진행하는 상황 -> 같은(혹은 더 나은)기능을 제공하는 새로운 시스템이 준비된 이후
	- 새로운 시스템이 낡은 시스템과 완벽히 동일하면 변경하는 이유가 없음. 즉 두 개의 시스템은 약간의 다른점(개선점)이 존재함
	- 따라서 폐기를 진행하기전에 기존 시스템과 새로운 시스템이 1:1로 모든 기능이 일치하는지 새로 확인해 봐야함.
- 옛 시스템에 대한 애착
	- 옛 시스템을 구축한 사람 등, 옛 시스템에 대한 애착히 큰 사람들이 존재함.
	- 새로운 코드로 이주하려 할 때 '난 이 코드가 좋아!' 같은 형태의 저항이 등장함.
- 폐기를 진행하기 위해서는 **정치**라는 관문도 통과해야함.
	- 오래된 시스템을 제거하는 데 드는 비용
		- 눈에 확실히 보이는 비용
		- 시스템을 방치해서 새어나가는 비용
	- 이러한 비용 때문에 새로운 시스템이 이득임을 이해관계자들에게 잘 설명 해야함.
### 설계 단계에서의 폐기
>언젠가는 폐기하게 될 시스템을 설계한다.
- 소프트웨어 엔지니어링에서는 생소하지만 다른 엔지니어 분야에서는 흔한 일
- 설계 단계에서 폐기를 고려하는 방법
	- 내 제품의 고객이 잠재적인 대체품으로 이주하기가 얼마나 쉬울까?
	- 내 시스템을 한 부분씩 점진적으로 교체하려면 어떻게 해야 할까?

## Types of Deprecation
### 권고 폐기(희망 폐기)
- 기한이 없고 조직에서도 우선순위가 높지 않은 경우
- 고객들이 새로운 시스템으로 이주하기를 바라지만 옛 시스템을 바로 걷어낼 계획은 없으며, 이주를 돕지도 않음
- 고객이 알아서 움직여주길 희망하는 것
- 새로운 시스템이 출시됐음을 알리고 얼리어답터들에게 이용해 보라고 권하기 좋은 수단
- 베타 수준에서는 시행하면 안되며, 정식 서비스가 가능한 수준에 올랐을 때 시행
### 강제 폐기
- 권고 폐기보다 더욱 적극적인 방식의 폐기 방법
- 낡은 시스템의 지원 종료일을 못 박는 형태로 이루어짐. -> 종료일이 지난 구식 시스템은 사용 불가
- 기존 시스템을 완전히 제거하는 역할을 전담할 팀을 하나 따로 꾸리는게 좋음.
	- 일정대로 집행할 수 있는 권한 부여
### 폐기 경고
- 폐기 대상임을 프로그래밍적으로 알려주는 것
	- 권고 폐기와 강제 폐기 모두 해당.
- 시스템 이용자가 폐기 사실을 인지해야 이주를 준비하기 때문이다.
- 폐기 경고를 한다고 해서 사람들이 폐기를 준비하는것은 아니다.
	- 새로운 사용자의 유입은 막을 수 있지만 기존 사용자를 이주시키는 데는 효과가 거의 없다.
- 경고가 많아 질 경우 오히려 이러한 경고를 무시하게 됨
	- **경보 피로** : 순식간에 범람하는 경고 메시지에 파묻혀서 경고를 아예 무시해버리는 현상
- 사용자에게 전달되는 폐기 경고 메시지에 반드시 담겨야 할 두 가지 특성
	- 실행 가능성
		- 해당 문제와 관련한 전문 지식을 갖춘 평균적인 엔지니어가 이론적으로 뿐 아니라 실질적인 조치를 취할 수 있을 가능성
	- 적시성
		- 폐기 경고가 유용하기 위해서는 적절한 시점에 떠야함. 
			- ex. 함수 폐기 경고는 엔지니어가 해당 함수를 사용하는 코드를 작성할 때 떠야함.
## Managing the Deprecation Process
### 프로세스 소유자
- 시스템이 아무리 경고를 쏟아내도 소유자가 명확하지 않으면 폐기 프로세스는 진행되지 않음.
- 소유권을 조정하다 보면 버려진 프로젝트에서 종종 발생하는 문제
	- 소유자 또는 유지보수 주체가 명확하지 않은 버려진 프로젝트
- 위와 같은 프로젝트는 최대한 빠르게 폐기 전문가를 배정하여 폐기를 해야함
	- 폐기 전문가가 시스템을 완벽하게 걷어내야 뜻하지 않은 문제를 접하지 않음.
	- 폐기 전문가의 팀은 시스템 제거를 사이드 프로젝트가 아닌 주된 목표로 잡고 진행해야함.
		- 다른 일과 경쟁하면 십중팔구 우선순위에서 밀리게 됨
### 마일스톤
- 새로운 시스템을 구축하면서 마일스톤을 명확하게 하는것과 마찬가지로 시스템 폐기 역시 마일스톤을 명확하게 해야함
- 낡은 시스템을 완전히 제거하는 것이 유일한 마일스톤이라 생각하면 안됨
	- 가장 의미있는 순간이지만, 팀 외부에서 가장 인지하기 어려운 마일스톤 이기도 함.
- 폐기팀을 관리할 때도 측정할 수 있고 고객에게 가치를 전달해주는 명확하고 점진적인 마일스톤을 세워야 함.
	- 핵심 컴포넌트들을 하나씩 제거하는 걸 점진적 마일스톤으로 삼으면 효과가 좋다.

### 폐기 도구
**1. 발견**
- 폐기를 진행하는 내내, 특히 프로세스 초기 단계에서는 낡은 시스템을 '**누가**', '**어떻게**' 이용하고 있는지를 알아야 한다.
- 어떻게 이용중 인지에 따라 폐기를 계속 진행할지 혹은 결정을 번복해야할지 검토해야 할 수 있다.

**2. 이주**
- 코드 생성 및 리뷰 도구들을 활용하여 이주를 적극 장려

**3. 퇴행 방지**
- 퇴행 : 새로 작성하는 코드에서 폐기 중인 대상을 이용하는 것
- 퇴행 방지는 폐기 지원 인프라가 챙겨야 할 중요한 역할임에도 자주 간과됨.
- 새로 커밋되는 코드에서 폐기 중인 시스템을 이용하려 할때 호가실한 경고를 해주어야 함.
