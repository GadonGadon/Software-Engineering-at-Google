
## 지속적인 배포
빠르게 변화하는 기술 사회에서는 제품 경쟁력을 갖추기 위해 시장에 신속하게 출시하는 것이 중요합니다. 즉, 유사 서비스와의 경쟁, 제품과 서비스 품질 유지, 새로운 규제에 적응, 조직의 반응 속도가 중요한 경쟁력이 된 것입니다.

이때, **배포 시간**이 이 경쟁력의 핵심입니다.  배포는 첫 론칭 때 단 한번만 이루어지는 것이 아닙니다. 처음부터 완벽한 소프트웨어튼 존재하지 않습니다. **빠르게 업데이트 하는 것만이 살아남을 수 있는 길**입니다. 

**살아남는 조직**들은 하나같이 **아이디어를 빠르게 실천**하고 **고객에게 전달**하여 **그들의 피드백을 반영**합니다.

고객에게 제품을 빨리 보여주는 것은 중요합니다. 숨기면 숨길 수록 위험과 비용이 커지며, 개발자들을 지치게 만듭니다. 그렇기에 **구글은** **초기에 최대한 자주 릴리즈 하도록** 격려합니다.
**

> 코드의 가치는 커밋 시점이 아니라 고객이 사용할 때 발현됩니다.

속도에 중점을 두고 **위험 관리**, 큰 조직에서의 **개발 속도 향상**, 출시한 뒤 **업데이트의 트레이드 오프**에 대해 알아보겠습니다.

## "빠를수록 안전하다"
지속적으로 배포할 준비가 되어 있지 않는 팀들이라면 동의하기 어려울 것입니다. 하지만 만약, 애자일 방법론을 고려한다면 아래의 키워드를 충분히 고려해볼만 합니다.

 - **민첩성** : 자주, 작게 릴리즈 합니다.
 - **자동화** : 잦은 릴리즈에 수반되는 반복적인 작업을 줄이거나 없앱니다.
 - **격리** : 변경을 격리하여 문제를 해결할 수 있도록 모듈화된 아키텍처를 지향합니다.
 - **신뢰성** : 비정상 종료와 지연시간 같은 주요 상태 지표를 측정하고 꾸준히 개선합니다.
 - **데이터 중심 의사 결정** : A/B 실험으로 상태 지표를 비교하여 품질을 높입니다.
 - **단계적 출시** : 변경사항을 대중에게 공개하기 보다는 소수에게 먼저 공개 합니다.

처음에는 신버전 소프트웨어를 자주 출시하는 게 위험해 보일 수 있습니다. 모든 **코드 줄들을 일일이 검사하기는 어렵기 때문**입니다. 하지만, 오히려 이점이 **지속적인 배포가 유용한 이유**입니다. 이상적으로는 두 **릴리스 사이의 변경이 적을 수록 더 큰 효과**를 거둘 수 있습니다. 당장 개발 과정을 지속적인 배포에 맞추어 모든 변경 사항이 개발 부터 검수, 배포까지 자동 가도록 변경할 순 없습니다. 하지만, 지속적인 배포가 가능하도록 서서히 바꿔갈 순 있습니다.

## 속도는 팀 스포츠와 같다  : 배포를 관리 가능한 수준으로 쪼개기.
팀이 작을 때는 변경들이 일정한 속도로 이루어 집니다. 하지만, 팀이 커지거나 하위 팀으로 쪼개지면서 문제가 생깁니다. **하위 팀들은 브랜치를 따서** 작업을 이어가게 되고, 이때문에 **통합할 때 생기는 문제**를 통합하는 것이 매우 힘들어집니다. 따라서 **구글은 코드베이스의 헤드**에서 개발하는 것을 선호합니다.
이와 관련된 CI 테스트, 자동 롤백, 문제 제공자를 찾는 방법은 23장에 상세히 설명해두었습니다.

조금더 설명하자면, 유튜브는 거대한 모놀리식 파이썬 어플리케이션이었습니다.
![Monolithic VS Microservice](https://user-images.githubusercontent.com/77031554/173368195-ee65cd2e-e326-43ff-9bcb-b405185cab2a.png)
한번 릴리즈 하려면 모든 팀들이 고통스러웠습니다. 작은 변경점 한번에 모든 팀들이 달려들어야했고 QA팀은 한번에 50시간이 걸리는 테스트도 해야했습니다. 릴리즈 시간이 천문학적으로 커짐에 따라 개발자 한명이 테스트를 해보기도 어려워졌습니다. 만약, 릴리즈 테스트 사이 또 한명이 개발한다면, 릴리즈 프로세스는 말도 안되게 복잡해졌습니다.
이게 끝이 아니었습니다. 결국, 릴리즈를 책임지던 한명이 도망쳤고 그로 인해 그 누구도 릴리즈시 발생하는 오류를 해결할 수 없는 지경에 이렀습니다.

**릴리즈 비용이 커지고 어려워질 수록 더 릴리즈를 기피**하게 됩니다. 마치 안정해보이지만, 그것은 **장기적 관점에서 매우 좋지 못합니다**. 답은 **릴리즈 비용을 줄이고 위험에 대해서는 꾸준히 대처하는 것**입니다. 당장의 안정을 위해 수정을 기피한다면 지금 당장 아키텍처를 수정해야합니다. 

가장 좋았던 해결책은 **마이크로서비스 아키텍처로의 전환**이었습니다. 구글은 제품을 단순 마이그레이션하는 것 보다 아예 처음부터 다시 짜는게 좋다는 걸 몸으로 배울 수 있었습니다. 수개월이 걸릴 수도 있고 굉장히 힘든 과정이지만, 코드의 수명을 고려할 땐 이 방법이 최선이었습니다.

## 변경사항을 격리해 평가한다 : 기능 플래그로 보호하기
지속적인 릴리즈를 안정적으로 수행하는 것에 대한 핵심은 엔지니어들이 모든 변경사항에 플래그 가드를 넣도록 하는 것입니다. **플래그 가드는 제품 코드를 기능 단위로 제어**(활성화/비활성화)하는 기법입니다. 릴리즈용 빌드냐 개발용 빌드냐에 따라 구분할 수 있습니다. **빌드 프로그램은 플래그를 확인하여 비활성화된 빌드를 제외**합니다. **검증이 완료된 기능들만 빌드**되도록합니다.

더 나아가 이전 버전의 기능을 실행하는 코드와 새로운 기능을 실행하는 코드를 모두 넣기도 합니다. 만약, 새로운 코드가 충분히 검증되었다고 판단되면 그때, 이전 버전을 수행하는 플래그를 끄고 새로운 코드를 실행할 수 있도록 합니다. 만약 문제가 생긴다면 플래그만 켜서 다시 이전버전으로 실행하도록 하면 됩니다.

제품 출시전 대중들에게 공개할 때 이 플래그가 큰 도움이 됩니다. 시연당시에는 플래그로 기능 수행을 막아서 기술 유출을 막을 수 있습니다.
플래그 가드와 같이 **릴리즈를 제어할 수 있는 능력은 제품을 오래 살아남을 수 있도록 하는 가장 중요한 경쟁력**입니다.

## 민첩하기 위한 노력 : 릴리즈 스케쥴링
처음 구글이 검색기능을 개발한 뒤로 수많은  기능들이 릴리즈 되었습니다. 하지만, 스마트폰 시대가 열리즈음 빌드를 배포하는 것은 점점 어려운 일이 됐습니다. 릴리즈 매니저는 하나하나 문제를 찾아야했고 이때문에 그는 쉬는 날이 거의 없었습니다.
결국 우리는 격일마다 릴리즈를 하도록 릴리즈의 주기를 정해 개발자들이 이에 맞출 수 있도록 했습니다.

## 완벽한 소프트웨어는 없다.
**릴리즈 일정을 지키기 위해** 우리는 첫째, **완벽한 바이너리는 없음**을 인정했습니다. 하지만, 아래와 같은 질문은 끊임없이 던져야합니다.

 - 선이 왼쪽으로 2픽셀만큼 움직이면 광고 수익이 줄어들까?
 - 박스 음영이 달라진다면?
 - 시각 장애인이 읽기 편할까?

릴리즈를 할 때마다 무언가를 결정하고 절충해야합니다. 핵심 성과 KPI(key performance indicator)와 트레숄드를 이용한다면 완벽하지는 않더라도 일단 릴리즈 할 수 있습니다.(SRE의 오차예산 공식을 따르는 것이 좋습니다. 어디까지 허용할 것인지, 결정하는 것은 매우 중요합니다.)
이 KPI는 규모와 상관없습니다.

> 한번은 필리핀의 한 작은 섬에서 사용하는 방언으로 구글 검색을 하면 빈 페이지만 보여주는 문제가 있었습니다. 릴리즈 시간은 다가오고 있었고 릴리즈 일정에 맞춰 이 버그를 무시할지, 릴리즈를 연기할지 결정해야했습니다. "매우 작은 필리핀 섬 하나를 위해 전체 릴리즈를 연기할까요?"라는 질문에 검색 부문 부사장은 "섬의 크기와 상관없이 검색기능은 항상 같은 결과를 보여줘야한다"였습니다. 릴리즈는 연기됐고 버그는 고쳐졌습니다.


## 릴리즈 시한을 반드시 지켜라
**두번째 릴리즈는 그 어떤 일이 있더라도 지켜진다는 것입니다.** 

> 마감일은 확실하지만, 인생은 그렇지 않다.

약속된 릴리즈 일정이 다가온다면 어느 시점부터는 더이상 수정해서는 안됩니다. 그 시점부터는 그 어떤 상황에서도 릴리즈를 방해받아선 안됩니다.
물론, 드물게 예외는 있습니다. 릴리즈 엔지니어의 워라벨을 위해 중간중간 릴리즈를 할 수 있도록 해주는 것 또한, 중요합니다.

## 품질과 사용자에게 집중하자 : 사용할 기능만 배포
대다수 소프트웨어는 사라지기전 부풀어 오릅니다. 성공할수록 더 그런 경향이 있습니다.  변하지 않는 릴리즈 일정은 이러한 단점을 극대화하게 됩니다. 고객들은 너무 자주 작은 업데이트를 경험하게 되고 개발자의 스트레스는 극에 달하게 됩니다. 따라서 구글은 동적으로 이를 절충했습니다. **동적으로 릴리즈 일정을 짜는 것의 핵심**은 **얼마나 자주 만들지**, **얼마나 사용자가 자주 받을지**를 구분해 관리하는 것입니다.
앞장에 말한 코드 모듈화를 이용한다면 동적으로 더욱 잘 배포전략을 구사할 수 있을 것입니다.  **코드 모듈화를 통해 고객들에게 의미있는 기능들만 잘게 쪼게 배포할 수 있습니다.**

## 원점회귀 : 데이터를 근거로 더 일찍 결정하자
매번 릴리즈 환경을 고려하는 것은 쉽지 않습니다. 따라서 구글은 릴리즈 승인 모델을 다음과 같이 바꾸었습니다.

 - 종합적인 테스트가 불가능 하다면, 대표적인 것들만 테스트한다.
 - 조금씩 사용자들에게 배포하면 문제를 빠르게 수정할 수 있다.
 - 자동화된 A/B릴리즈를 이용하면 릴리즈 품질 판별에 도움되는 중요한결과를 얻을 수 있다.
 
 **A/B테스트는 일부 사용자에게는 업데이트를 적용한 프로그램을 배포하고, 다른 사용자에게는 비교용으로 전과 똑같은 프로그램을 배포하는 식으로 이루어 집니다**. 이런식으로 충분한 수를 배포한 다음 두 사용자 그룹을 비교하면, 실제 새로운 버전이 의미있는지 판단할 수 있습니다. 사용자 수가 많다면 몇시간안에 중요한 데이터를 얻을 수 있습니다.

만약, 사용자 수가 충분하지 않다면, **중립적인 릴리즈**가 좋습니다. **새로운 기능을 모두 플래그로 막아두고 배포하는 것**입니다. 이 과정에서 **배표과정에서 발생하는 배포 자체의 안정성**은 검증할 수 있습니다.
## 배포 규율 세우기
늘 배포하라는 정책은 개발속도를 높여줍니다. 또한, 규모의 문제를 완화해주는 방법도 있습니다.

제품 출시 초기에는 팀원이 적어 각각이 배포와 모니터링 역할을 번갈아 맡을 수 있습니다. 하지만, 조직이 비대해질 수록 변경의 수는 기하급수적으로 증가하고 릴리즈의 위험은 급격하게 늘어납니다. 릴리즈 한번마다 수개월의 피땀눈물이 서릴 수도 있습니다. 

**릴리즈 일정을 세우는 것은 그래서 중요합니다.** 릴리즈가 다가오면 잠시 **변경 사항들은 미뤄두고 릴리즈에 집중하는 것**을 통해 코드가 커지더라도 변경에 대한 개발자들의 두려움은 줄일 수 있습니다.
강력한 규칙에 기반한 인터페이스, 엄격한 테스트, 잦은 소통, 새로운 기능을 수용하는 조건등을 통해 새로운 기능들은 기존 기능들과 명백히 구분되야합니다.

## 마치며
구글이 매일 배포하는 유튜브도 전날과는 달라보이지 않습니다. 하지만, 이렇게 히기위해서는 견고하고 잘 구성된 문서화된 배포 프로세스, 고객 만족도와 제품 상태를 정확하게 확인할 수 있는 실시간 지표, 명확한 기준을 가진 릴리즈 팀 이 모든 것이 갖추어져 있어야합니다. 소프트웨어 기능들은 제품 사용환경에서 언제든 설정을 통해 빼고 넣고 할 수 있도록 관리되야하며, 이 설정 정보들은 코드처럼 버전이 관리되야합니다.
